# Feature compatibility test suite for jq-compatible tools
# Format: filter / input / expected output (same as jq.test)
# Metadata: # category: ..., # feature: ..., # flags: ...

# category: Types and basic filters

# feature: Identity
.
42
42

.
{"a":1,"b":2}
{"a":1,"b":2}

# feature: Field access
.foo
{"foo":"bar","baz":1}
"bar"

.["foo"]
{"foo":"bar"}
"bar"

# feature: Optional field
.foo?
{"bar":1}
null

{a: .a, b: .b?}
{"a":1}
{"a":1,"b":null}

# feature: Array index
.[0]
[10,20,30]
10

.[-1]
[10,20,30]
30

# feature: Array/string slice
.[2:5]
[0,1,2,3,4,5,6]
[2,3,4]

.[3:]
[0,1,2,3,4,5]
[3,4,5]

.[:2]
"hello"
"he"

# feature: Iterator
[.[]?]
[1,2,3]
[1,2,3]

[.[]?]
{"a":1,"b":2}
[1,2]

# feature: Recursive descent
[.. | numbers]
{"a":{"b":1},"c":2}
[1,2]

[.. | strings]
{"a":"x","b":{"c":"y"}}
["x","y"]

# feature: Type literals
null
null
null

[true, false, 42, "str"]
null
[true,false,42,"str"]

# feature: type
type
42
"number"

type
"hello"
"string"

type
[1,2]
"array"

# category: Operators

# feature: Addition
. + 1
2
3

. + " world"
"hello"
"hello world"

. + [3,4]
[1,2]
[1,2,3,4]

# feature: Subtraction
. - 3
10
7

. - [2,4]
[1,2,3,4,5]
[1,3,5]

# feature: Multiplication
. * 3
7
21

{a:{b:1}} * {a:{c:2}}
null
{"a":{"b":1,"c":2}}

# feature: Division
. / 3
10
3.3333333333333335

"a,b,c" / ","
null
["a","b","c"]

# feature: Modulo
17 % 5
null
2

# feature: Equality
.x == 1
{"x":1}
true

.x != 2
{"x":1}
true

# feature: Comparison
.x > 5
{"x":10}
true

.x <= 5
{"x":3}
true

# feature: and/or
.a and .b
{"a":true,"b":false}
false

.a or .b
{"a":false,"b":true}
true

# feature: not
true | not
null
false

false | not
null
true

# feature: Alternative operator
.x // "default"
{"x":null}
"default"

.x // "default"
{"x":42}
42

# feature: Pipe
.a | .b
{"a":{"b":"nested"}}
"nested"

# feature: Comma
.a, .b
{"a":1,"b":2}
1
2

# feature: Unary negation
-(. + 1)
5
-6

# category: Control flow

# feature: if-then-else-end
if .x > 0 then "pos" else "neg" end
{"x":5}
"pos"

if .x > 0 then "pos" else "neg" end
{"x":-1}
"neg"

# feature: elif
if . == 1 then "a" elif . == 2 then "b" else "c" end
2
"b"

if . == 1 then "a" elif . == 2 then "b" elif . == 3 then "c" else "d" end
3
"c"

# feature: try
(try error("x")), 1
null
1

try .foo
{"foo":1}
1

# feature: try-catch
try error("fail") catch .
null
"fail"

try (1/0) catch "division error"
null
"division error"

# feature: Variable binding
.name as $n | {name: $n}
{"name":"alice"}
{"name":"alice"}

1 as $x | 2 as $y | $x + $y
null
3

# feature: reduce
reduce .[] as $x (0; . + $x)
[1,2,3,4,5]
15

reduce .[] as $x (""; . + $x)
["a","b","c"]
"abc"

# feature: foreach
[foreach .[] as $x (0; . + $x)]
[1,2,3]
[1,3,6]

[foreach .[] as $x (0; . + 1)]
["a","b","c"]
[1,2,3]

# feature: def
def double: . * 2; 5 | double
null
10

def addtwo: . + 2; [1,2,3] | map(addtwo)
null
[3,4,5]

# feature: def with args
def f(x): x | x; 1 | [f(. + 1)]
null
[3]

def addthem(x;y): x + y; addthem(2;3)
null
5

# feature: label-break
label $out | foreach range(5) as $x (0; . + $x; if . > 3 then ., break $out else . end)
null
0
1
3
6

# feature: empty
[1, empty, 2]
null
[1,2]

# feature: error
try error("fail") catch .
null
"fail"

try error catch .
null
null

# category: Array functions

# feature: length
length
[1,2,3]
3

length
"hello"
5

length
{"a":1,"b":2}
2

# feature: reverse
reverse
[1,2,3]
[3,2,1]

# feature: sort
sort
[3,1,4,1,5]
[1,1,3,4,5]

# feature: sort_by
sort_by(.a)
[{"a":3},{"a":1},{"a":2}]
[{"a":1},{"a":2},{"a":3}]

sort_by(.name)
[{"name":"bob"},{"name":"alice"}]
[{"name":"alice"},{"name":"bob"}]

# feature: group_by
group_by(.a)
[{"a":1,"b":"x"},{"a":2,"b":"y"},{"a":1,"b":"z"}]
[[{"a":1,"b":"x"},{"a":1,"b":"z"}],[{"a":2,"b":"y"}]]

# feature: unique
unique
[1,2,1,3,2]
[1,2,3]

# feature: unique_by
unique_by(.a)
[{"a":1,"b":2},{"a":1,"b":3},{"a":2,"b":4}]
[{"a":1,"b":2},{"a":2,"b":4}]

# feature: min/max
min
[3,1,4,1,5]
1

max
[3,1,4,1,5]
5

# feature: min_by/max_by
min_by(.a)
[{"a":3},{"a":1},{"a":2}]
{"a":1}

max_by(.a)
[{"a":3},{"a":1},{"a":2}]
{"a":3}

# feature: add
add
[1,2,3,4]
10

add
["a","b","c"]
"abc"

add
[[1,2],[3,4]]
[1,2,3,4]

# feature: flatten
flatten
[[1,[2]],3,[4,[5,[6]]]]
[1,2,3,4,5,6]

flatten(1)
[[1,[2]],[3,[4]]]
[1,[2],3,[4]]

# feature: transpose
transpose
[[1,2],[3,4]]
[[1,3],[2,4]]

# feature: contains
contains([2,3])
[1,2,3,4]
true

contains({"a":1})
{"a":1,"b":2}
true

# feature: inside
inside([1,2,3])
[2,3]
true

# feature: index/rindex
index("bc")
"abcabc"
1

rindex("bc")
"abcabc"
4

# feature: indices
indices("bc")
"abcabc"
[1,4]

# feature: first/last
first
[10,20,30]
10

last
[10,20,30]
30

# feature: first(f)/last(f)
first(range(10))
null
0

last(range(5))
null
4

# feature: nth
nth(2; range(10))
null
2

# feature: range
[range(4)]
null
[0,1,2,3]

[range(2;5)]
null
[2,3,4]

[range(0;10;3)]
null
[0,3,6,9]

# feature: any/all
any(. > 2)
[1,2,3]
true

all(. > 0)
[1,2,3]
true

any(. > 10)
[1,2,3]
false

# feature: map
map(. + 10)
[1,2,3]
[11,12,13]

map(. * 2)
[5,10,15]
[10,20,30]

# feature: map_values
map_values(. + 10)
{"a":1,"b":2}
{"a":11,"b":12}

# feature: select
[.[] | select(. > 2)]
[1,2,3,4,5]
[3,4,5]

[.[] | select(.active)]
[{"name":"a","active":true},{"name":"b","active":false}]
[{"name":"a","active":true}]

# feature: limit
[limit(3; range(100))]
null
[0,1,2]

# feature: until
0 | until(. >= 5; . + 1)
null
5

# feature: while
[1 | while(. < 8; . * 2)]
null
[1,2,4]

# feature: repeat
1 | [limit(4; repeat(. * 2))]
null
[2,2,2,2]

# feature: recurse
2 | [recurse(. * .; . < 100)]
null
[2,4,16]

# feature: isempty
isempty(empty)
null
true

isempty(range(3))
null
false

# feature: walk
[1,[2,[3]]] | walk(if type == "array" then sort else . end)
null
[1,[2,[3]]]

{"a":1,"b":{"c":2}} | walk(if type == "number" then . + 1 else . end)
null
{"a":2,"b":{"c":3}}

# feature: combinations
[[1,2],[3,4]] | [combinations]
null
[[1,3],[1,4],[2,3],[2,4]]

[combinations(2)]
[0,1]
[[0,0],[0,1],[1,0],[1,1]]

# feature: bsearch
bsearch(2)
[1,2,3,4,5]
1

bsearch(0)
[1,2,3]
-1

# feature: pick
pick(.a, .b.c)
{"a":1,"b":{"c":2,"d":3},"e":4}
{"a":1,"b":{"c":2}}

# category: Object functions

# feature: keys
keys
{"b":2,"a":1,"c":3}
["a","b","c"]

# feature: keys_unsorted
keys_unsorted
{"b":2,"a":1,"c":3}
["b","a","c"]

# feature: values (iterate)
[.[]]
{"a":1,"b":2,"c":3}
[1,2,3]

# feature: values (type selector)
[.[] | values]
[1,null,2,null,3]
[1,2,3]

# feature: has
has("a")
{"a":1,"b":2}
true

has("c")
{"a":1,"b":2}
false

has(1)
[10,20,30]
true

# feature: in
"a" | in({"a":1,"b":2})
null
true

"c" | in({"a":1,"b":2})
null
false

# feature: to_entries
to_entries
{"a":1,"b":2}
[{"key":"a","value":1},{"key":"b","value":2}]

# feature: from_entries
from_entries
[{"key":"a","value":1},{"key":"b","value":2}]
{"a":1,"b":2}

from_entries
[{"name":"a","value":1}]
{"a":1}

# feature: with_entries
with_entries(select(.value > 1))
{"a":1,"b":2,"c":3}
{"b":2,"c":3}

with_entries(.value += 10)
{"a":1,"b":2}
{"a":11,"b":12}

# feature: del
del(.a)
{"a":1,"b":2,"c":3}
{"b":2,"c":3}

del(.a.b)
{"a":{"b":1,"c":2},"d":3}
{"a":{"c":2},"d":3}

del(.[1])
[1,2,3]
[1,3]

# feature: paths
[paths]
{"a":{"b":1},"c":2}
[["a"],["a","b"],["c"]]

[paths(type == "number")]
{"a":{"b":1},"c":"x"}
[["a","b"]]

# feature: path
path(.a.b)
{"a":{"b":1}}
["a","b"]

path(.a[0])
{"a":[10,20]}
["a",0]

# feature: leaf_paths
[paths(scalars)]
{"a":{"b":1},"c":2}
[["a","b"],["c"]]

# feature: getpath
getpath(["a","b"])
{"a":{"b":42}}
42

getpath(["x"])
{"a":1}
null

# feature: setpath
setpath(["a","b"]; 42)
{}
{"a":{"b":42}}

setpath(["a"]; 1)
{"a":0,"b":2}
{"a":1,"b":2}

# feature: delpaths
delpaths([["a"],["c"]])
{"a":1,"b":2,"c":3}
{"b":2}

# category: String functions

# feature: tostring
tostring
42
"42"

tostring
true
"true"

# feature: tonumber
tonumber
"42"
42

tonumber
"3.14"
3.14

# feature: split
split(",")
"a,b,c"
["a","b","c"]

split("")
"abc"
["a","b","c"]

# feature: join
join(",")
["a","b","c"]
"a,b,c"

join("")
["x","y","z"]
"xyz"

# feature: ltrimstr/rtrimstr
ltrimstr("hello")
"hello world"
" world"

rtrimstr(".txt")
"readme.txt"
"readme"

# feature: startswith/endswith
startswith("he")
"hello"
true

endswith(".json")
"data.json"
true

# feature: ascii_upcase/ascii_downcase
ascii_upcase
"Hello World"
"HELLO WORLD"

ascii_downcase
"Hello World"
"hello world"

# feature: explode/implode
explode
"abc"
[97,98,99]

implode
[72,101,108,108,111]
"Hello"

# feature: tojson/fromjson
tojson
[1,2,3]
"[1,2,3]"

fromjson
"[1,2,3]"
[1,2,3]

# feature: utf8bytelength
utf8bytelength
"abc"
3

# feature: String interpolation
"name: \(.name), age: \(.age)"
{"name":"alice","age":30}
"name: alice, age: 30"

"sum: \(.a + .b)"
{"a":1,"b":2}
"sum: 3"

# feature: test
test("^foo")
"foobar"
true

test("^foo")
"barfoo"
false

test("FOO"; "i")
"foobar"
true

# feature: match
match("(o+)")
"foobar"
{"offset":1,"length":2,"string":"oo","captures":[{"offset":1,"length":2,"string":"oo","name":null}]}

# feature: capture
capture("(?<y>\\d{4})-(?<m>\\d{2})")
"2024-01-15"
{"y":"2024","m":"01"}

# feature: sub/gsub
gsub("o"; "0")
"foobar"
"f00bar"

sub("o"; "0")
"foobar"
"f0obar"

# feature: scan
[scan("[0-9]+")]
"test 123 test 456"
["123","456"]

# feature: splits
[splits("[,;]")]
"a,b;c"
["a","b","c"]

# category: Math functions

# feature: floor/ceil/round
floor
3.7
3

ceil
3.2
4

round
3.5
4

# feature: sqrt
sqrt
9
3

# feature: fabs
fabs
-5
5

fabs
5
5

# feature: exp/exp2
1 | exp
null
2.718281828459045

3 | exp2
null
8

# feature: log/log2/log10
100 | log10
null
2

8 | log2
null
3

# feature: pow
pow(2;10)
null
1024

pow(3;3)
null
27

# feature: sin/cos/tan
0 | cos
null
1

0 | sin
null
0

# feature: asin/acos/atan
1 | acos
null
0

0 | asin
null
0

# feature: atan2
atan2(0;-1)
null
3.141592653589793

# feature: sinh/cosh/tanh
0 | sinh
null
0

0 | cosh
null
1

# feature: nan/infinite
nan | isnan
null
true

infinite | isinfinite
null
true

# feature: isnan/isinfinite/isfinite/isnormal
1 | isfinite
null
true

1 | isnormal
null
true

0 | isnan
null
false

# feature: logb
8 | logb
null
3

# feature: significand
8 | significand
null
1

16 | significand
null
1

# feature: nearbyint/rint
3.7 | nearbyint
null
4

3.2 | rint
null
3

# feature: remainder/hypot
hypot(3;4)
null
5

remainder(10;3)
null
1

# category: Type selectors

# feature: arrays
[.[] | arrays]
[1,[2],{"a":3},"s",[4,5]]
[[2],[4,5]]

# feature: objects
[.[] | objects]
[1,[2],{"a":3},"s",{"b":4}]
[{"a":3},{"b":4}]

# feature: numbers
[.[] | numbers]
[1,"a",2,null,3]
[1,2,3]

# feature: strings
[.[] | strings]
[1,"a",2,"b",null]
["a","b"]

# feature: booleans
[.[] | booleans]
[1,true,"a",false,null]
[true,false]

# feature: nulls
[.[] | nulls]
[1,null,2,null,3]
[null,null]

# feature: values (selector)
[.[] | values]
[1,null,2,null,3]
[1,2,3]

# feature: scalars
[.[] | scalars]
[1,"a",[2],{"b":3},null,true]
[1,"a",null,true]

# feature: iterables
[.[] | iterables]
[1,"a",[2],{"b":3},null]
[[2],{"b":3}]

# category: Format strings

# feature: @base64
@base64
"hello"
"aGVsbG8="

@base64d
"aGVsbG8="
"hello"

# feature: @uri
@uri
"hello world"
"hello%20world"

# feature: @csv
@csv
["a","b","c"]
"\"a\",\"b\",\"c\""

@csv
[1,2,3]
"1,2,3"

# feature: @tsv
@tsv
["a","b","c"]
"a\tb\tc"

# feature: @html
@html
"<b>bold</b>"
"&lt;b&gt;bold&lt;/b&gt;"

# feature: @sh
@sh
"hello world"
"'hello world'"

# feature: @json
@json
[1,2,3]
"[1,2,3]"

# feature: @text
@text
42
"42"

# category: Date/time

# feature: todate
0 | todate
null
"1970-01-01T00:00:00Z"

86400 | todate
null
"1970-01-02T00:00:00Z"

# feature: fromdate
"1970-01-01T00:00:00Z" | fromdate
null
0

# feature: strftime
0 | strftime("%Y-%m-%d")
null
"1970-01-01"

0 | strftime("%H:%M:%S")
null
"00:00:00"

# feature: strptime
"2024-01-15" | strptime("%Y-%m-%d")
null
[2024,0,15,0,0,0,1,14]

# feature: gmtime/mktime
0 | gmtime
null
[1970,0,1,0,0,0,4,0]

0 | gmtime | mktime
null
0

# feature: now
now | . > 0
null
true

# category: Assignment operators

# feature: Update assignment
.a |= . + 1
{"a":1,"b":2}
{"a":2,"b":2}

.[] |= . * 2
[1,2,3]
[2,4,6]

# feature: Arithmetic assignment
.a += 10
{"a":1,"b":2}
{"a":11,"b":2}

.a -= 1
{"a":5}
{"a":4}

# feature: Alternative assignment
.a //= "default"
{"a":null,"b":2}
{"a":"default","b":2}

.a //= "default"
{"a":1,"b":2}
{"a":1,"b":2}

# feature: Plain assignment
.a = 42
{"a":1,"b":2}
{"a":42,"b":2}

.c = "new"
{"a":1}
{"a":1,"c":"new"}

# category: I/O and environment

# feature: env
env.HOME | length > 0
null
true

$ENV.HOME | length > 0
null
true

# feature: debug
42 | debug | . + 1
null
43

# feature: builtins
builtins | length > 0
null
true

[builtins[] | select(startswith("length"))] | length > 0
null
true

# feature: input/inputs
# flags: -cn --
[inputs]
1\n2\n3
[1,2,3]

# feature: halt/halt_error
# These are hard to test via output comparison; just test null output from halt
# Skipping â€” halt terminates the process and can't be easily tested in this harness

# category: SQL-style operators

# feature: IN
3 | IN(1, 2, 3)
null
true

5 | IN(1, 2, 3)
null
false

# feature: IN (stream form)
[.[] | select(IN(1, 3, 5))]
[1,2,3,4,5]
[1,3,5]

# feature: INDEX
INDEX(.[]; .name)
[{"name":"a","v":1},{"name":"b","v":2}]
{"a":{"name":"a","v":1},"b":{"name":"b","v":2}}

# feature: GROUP_BY
[group_by(.a)[] | {key: .[0].a, count: length}]
[{"a":1,"b":"x"},{"a":2,"b":"y"},{"a":1,"b":"z"}]
[{"key":1,"count":2},{"key":2,"count":1}]

# category: CLI flags

# feature: Compact output
# flags: -c
.
{"a":1,"b":2}
{"a":1,"b":2}

# feature: Raw output
# flags: -r
.name
{"name":"hello"}
hello

# feature: Null input
# flags: -cn --
{a:1, b:2}
null
{"a":1,"b":2}

# feature: Exit status
# flags: -e -c --
select(. > 0)
3
3

# feature: Tab indentation
# flags: --tab --
. + 1
1
2

# feature: Indent
# flags: --indent 4 --
. + 1
1
2

# feature: Slurp
# flags: -cs --
.
[1]\n[2]\n[3]
[[1],[2],[3]]

# feature: Sort keys
# flags: -Sc --
.
{"b":2,"a":1}
{"a":1,"b":2}

# feature: Raw input
# flags: -Rc --
.
hello
"hello"

# feature: Join output
# flags: -rj --
.name
{"name":"hello"}
hello

# feature: --arg
# flags: -c --arg name alice
{name: $name}
null
{"name":"alice"}

# feature: --argjson
# flags: -c --argjson n 42
{val: $n}
null
{"val":42}

# feature: --from-file
# This requires a file on disk, hard to test in this harness; skip

# feature: --slurpfile
# This requires a file on disk, hard to test in this harness; skip

# feature: Monochrome output
# flags: -Mc --
.
{"a":1}
{"a":1}

# feature: --jsonl
# flags: --jsonl -c --
.x
{"x":1}
1
